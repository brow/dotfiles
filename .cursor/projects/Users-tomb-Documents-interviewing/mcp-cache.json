{
  "jira": {
    "tools": [
      {
        "name": "create_issue",
        "description": "Create a new Jira issue",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectKey": {
              "type": "string",
              "description": "Project key (e.g., \"PROJ\")"
            },
            "summary": {
              "type": "string",
              "description": "Issue summary/title"
            },
            "issueType": {
              "type": "string",
              "description": "Type of issue (e.g., \"Task\", \"Bug\", \"Story\")"
            },
            "description": {
              "type": "string",
              "description": "Detailed description of the issue"
            },
            "assignee": {
              "type": "string",
              "description": "Account ID of the assignee. Use get_user tool to find account ID by email."
            },
            "labels": {
              "type": "string",
              "description": "Comma-separated list of labels"
            },
            "components": {
              "type": "string",
              "description": "Comma-separated list of component names"
            },
            "priority": {
              "type": "string",
              "description": "Issue priority"
            },
            "parent": {
              "type": "string",
              "description": "Parent issue key for subtasks"
            },
            "customFields": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "name": {
                    "type": "string",
                    "description": "Field name"
                  },
                  "id": {
                    "type": "string",
                    "description": "Field ID"
                  },
                  "schema": {
                    "type": "object",
                    "properties": {
                      "type": {
                        "type": "string",
                        "description": "Field type"
                      },
                      "custom": {
                        "type": "string",
                        "description": "Custom field type"
                      }
                    },
                    "required": [
                      "type"
                    ],
                    "additionalProperties": false,
                    "description": "Field schema"
                  },
                  "value": {
                    "description": "Field value"
                  }
                },
                "required": [
                  "name",
                  "id",
                  "schema"
                ],
                "additionalProperties": false
              },
              "description": "Custom fields in JSON format"
            }
          },
          "required": [
            "projectKey",
            "summary",
            "issueType"
          ],
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        }
      },
      {
        "name": "update_issue",
        "description": "Update an existing Jira issue",
        "inputSchema": {
          "type": "object",
          "properties": {
            "issueKey": {
              "type": "string",
              "description": "Key of the issue to update"
            },
            "summary": {
              "type": "string",
              "description": "New summary/title"
            },
            "description": {
              "type": "string",
              "description": "New description"
            },
            "assignee": {
              "type": "string",
              "description": "Account ID of new assignee. Use get_user tool to find account ID by email."
            },
            "status": {
              "type": "string",
              "description": "New status"
            },
            "priority": {
              "type": "string",
              "description": "New priority"
            },
            "parent": {
              "type": "string",
              "description": "New parent issue key for subtasks"
            },
            "comment": {
              "type": "string",
              "description": "Comment to add or update"
            },
            "commentId": {
              "type": "string",
              "description": "ID of the comment to update (must be a valid number)"
            },
            "labels": {
              "type": "string",
              "description": "Comma-separated list of labels"
            },
            "components": {
              "type": "string",
              "description": "Comma-separated list of component names"
            },
            "customFields": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "name": {
                    "type": "string",
                    "description": "Field name"
                  },
                  "id": {
                    "type": "string",
                    "description": "Field ID"
                  },
                  "schema": {
                    "type": "object",
                    "properties": {
                      "type": {
                        "type": "string",
                        "description": "Field type"
                      },
                      "custom": {
                        "type": "string",
                        "description": "Custom field type"
                      }
                    },
                    "required": [
                      "type"
                    ],
                    "additionalProperties": false,
                    "description": "Field schema"
                  },
                  "value": {
                    "description": "Field value"
                  }
                },
                "required": [
                  "name",
                  "id",
                  "schema"
                ],
                "additionalProperties": false
              },
              "description": "Custom fields in JSON format"
            }
          },
          "required": [
            "issueKey"
          ],
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        }
      },
      {
        "name": "get_issues",
        "description": "Get all issues and subtasks for a Jira project.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectKey": {
              "type": "string",
              "description": "Project key (e.g., \"PROJ\")"
            },
            "maxResults": {
              "type": "string",
              "description": "Maximum number of results to return (default: 50)"
            },
            "startAt": {
              "type": "string",
              "description": "Index to start pagination (default: 0)"
            },
            "jql": {
              "type": "string",
              "description": "Optional JQL to filter issues. Use currentUser() to return the requesting user's issues"
            },
            "fields": {
              "type": "string",
              "description": "Comma-separated list of fields to include in response"
            }
          },
          "required": [
            "projectKey"
          ],
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        }
      },
      {
        "name": "delete_issue",
        "description": "Delete a Jira issue or subtask",
        "inputSchema": {
          "type": "object",
          "properties": {
            "issueKey": {
              "type": "string",
              "description": "Key of the issue to delete"
            }
          },
          "required": [
            "issueKey"
          ],
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        }
      },
      {
        "name": "get_user",
        "description": "Get a user's account information by their email address.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "email": {
              "type": "string",
              "description": "User's email address"
            }
          },
          "required": [
            "email"
          ],
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        }
      },
      {
        "name": "create_issue_link",
        "description": "Create a link between two issues",
        "inputSchema": {
          "type": "object",
          "properties": {
            "inwardIssueKey": {
              "type": "string",
              "description": "Key of the inward issue (e.g., blocked issue)"
            },
            "outwardIssueKey": {
              "type": "string",
              "description": "Key of the outward issue (e.g., blocking issue)"
            },
            "linkType": {
              "type": "string",
              "description": "Type of link (e.g., 'blocks')"
            }
          },
          "required": [
            "inwardIssueKey",
            "outwardIssueKey",
            "linkType"
          ],
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        }
      },
      {
        "name": "list_issue_types",
        "description": "List all available issue types, optionally filtered by project",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectKey": {
              "type": "string",
              "description": "Project key (e.g., \"PROJ\")"
            }
          },
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        }
      },
      {
        "name": "list_link_types",
        "description": "List all available issue link types",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        }
      },
      {
        "name": "get_issue_create_metadata",
        "description": "Get issue create metadata for a project with optional issue type filtering",
        "inputSchema": {
          "type": "object",
          "properties": {
            "projectKey": {
              "type": "string",
              "description": "Project key (e.g., \"PROJ\")"
            },
            "issueTypeNames": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Issue types to filter by."
            },
            "includeOptionalFields": {
              "type": "boolean",
              "description": "Whether to include optional fields in the metadata (default: false)"
            }
          },
          "required": [
            "projectKey"
          ],
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        }
      },
      {
        "name": "get_comments",
        "description": "Get all comments from a Jira issue",
        "inputSchema": {
          "type": "object",
          "properties": {
            "issueKey": {
              "type": "string",
              "description": "Key of the issue to get comments from"
            }
          },
          "required": [
            "issueKey"
          ],
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        }
      },
      {
        "name": "delete_comment",
        "description": "Delete a comment from a Jira issue",
        "inputSchema": {
          "type": "object",
          "properties": {
            "issueKey": {
              "type": "string",
              "description": "Key of the issue containing the comment"
            },
            "commentId": {
              "type": "string",
              "description": "ID of the comment to delete (must be a valid number)"
            }
          },
          "required": [
            "issueKey",
            "commentId"
          ],
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        }
      },
      {
        "name": "get_all_boards",
        "description": "Get all boards the user has access to",
        "inputSchema": {
          "type": "object",
          "properties": {
            "startAt": {
              "type": "string",
              "description": "The starting index of the returned boards"
            },
            "maxResults": {
              "type": "string",
              "description": "The maximum number of boards to return per page"
            },
            "projectKeyOrId": {
              "type": "string",
              "description": "Filter results to boards that are relevant to a project"
            },
            "type": {
              "type": "string",
              "description": "Filter results to boards of the specified type (scrum, kanban)"
            },
            "name": {
              "type": "string",
              "description": "Filter results to boards that match or partially match the specified name"
            }
          },
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        }
      },
      {
        "name": "get_board",
        "description": "Get details about a specific board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "boardId": {
              "type": "string",
              "description": "ID of the board to retrieve"
            }
          },
          "required": [
            "boardId"
          ],
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        }
      },
      {
        "name": "get_all_sprints",
        "description": "Get all sprints in a board",
        "inputSchema": {
          "type": "object",
          "properties": {
            "boardId": {
              "type": "string",
              "description": "ID of the board to get sprints from"
            },
            "startAt": {
              "type": "string",
              "description": "The starting index of the returned sprints"
            },
            "maxResults": {
              "type": "string",
              "description": "The maximum number of sprints to return per page"
            },
            "state": {
              "type": "string",
              "description": "Filter by sprint state (future, active, closed)"
            }
          },
          "required": [
            "boardId"
          ],
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        }
      },
      {
        "name": "get_sprint_issues",
        "description": "Get all issues in a sprint",
        "inputSchema": {
          "type": "object",
          "properties": {
            "boardId": {
              "type": "string",
              "description": "ID of the board"
            },
            "sprintId": {
              "type": "string",
              "description": "ID of the sprint to get issues from"
            },
            "startAt": {
              "type": "string",
              "description": "The starting index of the returned issues"
            },
            "maxResults": {
              "type": "string",
              "description": "The maximum number of issues to return per page"
            },
            "jql": {
              "type": "string",
              "description": "Filter results using a JQL query"
            }
          },
          "required": [
            "boardId",
            "sprintId"
          ],
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        }
      },
      {
        "name": "move_issues_to_epic",
        "description": "Move issues to a specific epic",
        "inputSchema": {
          "type": "object",
          "properties": {
            "epicId": {
              "type": "string",
              "description": "The ID of the epic to move issues to"
            },
            "issueKeys": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "List of issue keys to move"
            }
          },
          "required": [
            "epicId",
            "issueKeys"
          ],
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        }
      },
      {
        "name": "get_current_user",
        "description": "Get information about the currently authenticated user",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        }
      },
      {
        "name": "get_user_issues",
        "description": "Get issues assigned to a specific user",
        "inputSchema": {
          "type": "object",
          "properties": {
            "username": {
              "type": "string",
              "description": "Email address of the user to get issues for"
            },
            "open": {
              "type": "string",
              "description": "If 'true', returns only open issues"
            }
          },
          "required": [
            "username",
            "open"
          ],
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        }
      }
    ]
  },
  "playwright": {
    "tools": [
      {
        "name": "browser_close",
        "description": "Close the page",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        },
        "annotations": {
          "title": "Close browser",
          "readOnlyHint": false,
          "destructiveHint": true,
          "openWorldHint": true
        }
      },
      {
        "name": "browser_resize",
        "description": "Resize the browser window",
        "inputSchema": {
          "type": "object",
          "properties": {
            "width": {
              "type": "number",
              "description": "Width of the browser window"
            },
            "height": {
              "type": "number",
              "description": "Height of the browser window"
            }
          },
          "required": [
            "width",
            "height"
          ],
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        },
        "annotations": {
          "title": "Resize browser window",
          "readOnlyHint": false,
          "destructiveHint": true,
          "openWorldHint": true
        }
      },
      {
        "name": "browser_console_messages",
        "description": "Returns all console messages",
        "inputSchema": {
          "type": "object",
          "properties": {
            "onlyErrors": {
              "type": "boolean",
              "description": "Only return error messages"
            }
          },
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        },
        "annotations": {
          "title": "Get console messages",
          "readOnlyHint": true,
          "destructiveHint": false,
          "openWorldHint": true
        }
      },
      {
        "name": "browser_handle_dialog",
        "description": "Handle a dialog",
        "inputSchema": {
          "type": "object",
          "properties": {
            "accept": {
              "type": "boolean",
              "description": "Whether to accept the dialog."
            },
            "promptText": {
              "type": "string",
              "description": "The text of the prompt in case of a prompt dialog."
            }
          },
          "required": [
            "accept"
          ],
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        },
        "annotations": {
          "title": "Handle a dialog",
          "readOnlyHint": false,
          "destructiveHint": true,
          "openWorldHint": true
        }
      },
      {
        "name": "browser_evaluate",
        "description": "Evaluate JavaScript expression on page or element",
        "inputSchema": {
          "type": "object",
          "properties": {
            "function": {
              "type": "string",
              "description": "() => { /* code */ } or (element) => { /* code */ } when element is provided"
            },
            "element": {
              "type": "string",
              "description": "Human-readable element description used to obtain permission to interact with the element"
            },
            "ref": {
              "type": "string",
              "description": "Exact target element reference from the page snapshot"
            }
          },
          "required": [
            "function"
          ],
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        },
        "annotations": {
          "title": "Evaluate JavaScript",
          "readOnlyHint": false,
          "destructiveHint": true,
          "openWorldHint": true
        }
      },
      {
        "name": "browser_file_upload",
        "description": "Upload one or multiple files",
        "inputSchema": {
          "type": "object",
          "properties": {
            "paths": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "The absolute paths to the files to upload. Can be single file or multiple files. If omitted, file chooser is cancelled."
            }
          },
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        },
        "annotations": {
          "title": "Upload files",
          "readOnlyHint": false,
          "destructiveHint": true,
          "openWorldHint": true
        }
      },
      {
        "name": "browser_fill_form",
        "description": "Fill multiple form fields",
        "inputSchema": {
          "type": "object",
          "properties": {
            "fields": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "name": {
                    "type": "string",
                    "description": "Human-readable field name"
                  },
                  "type": {
                    "type": "string",
                    "enum": [
                      "textbox",
                      "checkbox",
                      "radio",
                      "combobox",
                      "slider"
                    ],
                    "description": "Type of the field"
                  },
                  "ref": {
                    "type": "string",
                    "description": "Exact target field reference from the page snapshot"
                  },
                  "value": {
                    "type": "string",
                    "description": "Value to fill in the field. If the field is a checkbox, the value should be `true` or `false`. If the field is a combobox, the value should be the text of the option."
                  }
                },
                "required": [
                  "name",
                  "type",
                  "ref",
                  "value"
                ],
                "additionalProperties": false
              },
              "description": "Fields to fill in"
            }
          },
          "required": [
            "fields"
          ],
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        },
        "annotations": {
          "title": "Fill form",
          "readOnlyHint": false,
          "destructiveHint": true,
          "openWorldHint": true
        }
      },
      {
        "name": "browser_install",
        "description": "Install the browser specified in the config. Call this if you get an error about the browser not being installed.",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        },
        "annotations": {
          "title": "Install the browser specified in the config",
          "readOnlyHint": false,
          "destructiveHint": true,
          "openWorldHint": true
        }
      },
      {
        "name": "browser_press_key",
        "description": "Press a key on the keyboard",
        "inputSchema": {
          "type": "object",
          "properties": {
            "key": {
              "type": "string",
              "description": "Name of the key to press or a character to generate, such as `ArrowLeft` or `a`"
            }
          },
          "required": [
            "key"
          ],
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        },
        "annotations": {
          "title": "Press a key",
          "readOnlyHint": false,
          "destructiveHint": true,
          "openWorldHint": true
        }
      },
      {
        "name": "browser_type",
        "description": "Type text into editable element",
        "inputSchema": {
          "type": "object",
          "properties": {
            "element": {
              "type": "string",
              "description": "Human-readable element description used to obtain permission to interact with the element"
            },
            "ref": {
              "type": "string",
              "description": "Exact target element reference from the page snapshot"
            },
            "text": {
              "type": "string",
              "description": "Text to type into the element"
            },
            "submit": {
              "type": "boolean",
              "description": "Whether to submit entered text (press Enter after)"
            },
            "slowly": {
              "type": "boolean",
              "description": "Whether to type one character at a time. Useful for triggering key handlers in the page. By default entire text is filled in at once."
            }
          },
          "required": [
            "element",
            "ref",
            "text"
          ],
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        },
        "annotations": {
          "title": "Type text",
          "readOnlyHint": false,
          "destructiveHint": true,
          "openWorldHint": true
        }
      },
      {
        "name": "browser_navigate",
        "description": "Navigate to a URL",
        "inputSchema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "The URL to navigate to"
            }
          },
          "required": [
            "url"
          ],
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        },
        "annotations": {
          "title": "Navigate to a URL",
          "readOnlyHint": false,
          "destructiveHint": true,
          "openWorldHint": true
        }
      },
      {
        "name": "browser_navigate_back",
        "description": "Go back to the previous page",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        },
        "annotations": {
          "title": "Go back",
          "readOnlyHint": false,
          "destructiveHint": true,
          "openWorldHint": true
        }
      },
      {
        "name": "browser_network_requests",
        "description": "Returns all network requests since loading the page",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        },
        "annotations": {
          "title": "List network requests",
          "readOnlyHint": true,
          "destructiveHint": false,
          "openWorldHint": true
        }
      },
      {
        "name": "browser_take_screenshot",
        "description": "Take a screenshot of the current page. You can't perform actions based on the screenshot, use browser_snapshot for actions.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "png",
                "jpeg"
              ],
              "default": "png",
              "description": "Image format for the screenshot. Default is png."
            },
            "filename": {
              "type": "string",
              "description": "File name to save the screenshot to. Defaults to `page-{timestamp}.{png|jpeg}` if not specified. Prefer relative file names to stay within the output directory."
            },
            "element": {
              "type": "string",
              "description": "Human-readable element description used to obtain permission to screenshot the element. If not provided, the screenshot will be taken of viewport. If element is provided, ref must be provided too."
            },
            "ref": {
              "type": "string",
              "description": "Exact target element reference from the page snapshot. If not provided, the screenshot will be taken of viewport. If ref is provided, element must be provided too."
            },
            "fullPage": {
              "type": "boolean",
              "description": "When true, takes a screenshot of the full scrollable page, instead of the currently visible viewport. Cannot be used with element screenshots."
            }
          },
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        },
        "annotations": {
          "title": "Take a screenshot",
          "readOnlyHint": true,
          "destructiveHint": false,
          "openWorldHint": true
        }
      },
      {
        "name": "browser_snapshot",
        "description": "Capture accessibility snapshot of the current page, this is better than screenshot",
        "inputSchema": {
          "type": "object",
          "properties": {},
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        },
        "annotations": {
          "title": "Page snapshot",
          "readOnlyHint": true,
          "destructiveHint": false,
          "openWorldHint": true
        }
      },
      {
        "name": "browser_click",
        "description": "Perform click on a web page",
        "inputSchema": {
          "type": "object",
          "properties": {
            "element": {
              "type": "string",
              "description": "Human-readable element description used to obtain permission to interact with the element"
            },
            "ref": {
              "type": "string",
              "description": "Exact target element reference from the page snapshot"
            },
            "doubleClick": {
              "type": "boolean",
              "description": "Whether to perform a double click instead of a single click"
            },
            "button": {
              "type": "string",
              "enum": [
                "left",
                "right",
                "middle"
              ],
              "description": "Button to click, defaults to left"
            },
            "modifiers": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "Alt",
                  "Control",
                  "ControlOrMeta",
                  "Meta",
                  "Shift"
                ]
              },
              "description": "Modifier keys to press"
            }
          },
          "required": [
            "element",
            "ref"
          ],
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        },
        "annotations": {
          "title": "Click",
          "readOnlyHint": false,
          "destructiveHint": true,
          "openWorldHint": true
        }
      },
      {
        "name": "browser_drag",
        "description": "Perform drag and drop between two elements",
        "inputSchema": {
          "type": "object",
          "properties": {
            "startElement": {
              "type": "string",
              "description": "Human-readable source element description used to obtain the permission to interact with the element"
            },
            "startRef": {
              "type": "string",
              "description": "Exact source element reference from the page snapshot"
            },
            "endElement": {
              "type": "string",
              "description": "Human-readable target element description used to obtain the permission to interact with the element"
            },
            "endRef": {
              "type": "string",
              "description": "Exact target element reference from the page snapshot"
            }
          },
          "required": [
            "startElement",
            "startRef",
            "endElement",
            "endRef"
          ],
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        },
        "annotations": {
          "title": "Drag mouse",
          "readOnlyHint": false,
          "destructiveHint": true,
          "openWorldHint": true
        }
      },
      {
        "name": "browser_hover",
        "description": "Hover over element on page",
        "inputSchema": {
          "type": "object",
          "properties": {
            "element": {
              "type": "string",
              "description": "Human-readable element description used to obtain permission to interact with the element"
            },
            "ref": {
              "type": "string",
              "description": "Exact target element reference from the page snapshot"
            }
          },
          "required": [
            "element",
            "ref"
          ],
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        },
        "annotations": {
          "title": "Hover mouse",
          "readOnlyHint": false,
          "destructiveHint": true,
          "openWorldHint": true
        }
      },
      {
        "name": "browser_select_option",
        "description": "Select an option in a dropdown",
        "inputSchema": {
          "type": "object",
          "properties": {
            "element": {
              "type": "string",
              "description": "Human-readable element description used to obtain permission to interact with the element"
            },
            "ref": {
              "type": "string",
              "description": "Exact target element reference from the page snapshot"
            },
            "values": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Array of values to select in the dropdown. This can be a single value or multiple values."
            }
          },
          "required": [
            "element",
            "ref",
            "values"
          ],
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        },
        "annotations": {
          "title": "Select option",
          "readOnlyHint": false,
          "destructiveHint": true,
          "openWorldHint": true
        }
      },
      {
        "name": "browser_tabs",
        "description": "List, create, close, or select a browser tab.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "action": {
              "type": "string",
              "enum": [
                "list",
                "new",
                "close",
                "select"
              ],
              "description": "Operation to perform"
            },
            "index": {
              "type": "number",
              "description": "Tab index, used for close/select. If omitted for close, current tab is closed."
            }
          },
          "required": [
            "action"
          ],
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        },
        "annotations": {
          "title": "Manage tabs",
          "readOnlyHint": false,
          "destructiveHint": true,
          "openWorldHint": true
        }
      },
      {
        "name": "browser_wait_for",
        "description": "Wait for text to appear or disappear or a specified time to pass",
        "inputSchema": {
          "type": "object",
          "properties": {
            "time": {
              "type": "number",
              "description": "The time to wait in seconds"
            },
            "text": {
              "type": "string",
              "description": "The text to wait for"
            },
            "textGone": {
              "type": "string",
              "description": "The text to wait for to disappear"
            }
          },
          "additionalProperties": false,
          "$schema": "http://json-schema.org/draft-07/schema#"
        },
        "annotations": {
          "title": "Wait for",
          "readOnlyHint": true,
          "destructiveHint": false,
          "openWorldHint": true
        }
      }
    ]
  },
  "Linear": {
    "tools": [
      {
        "name": "execute_readonly_query",
        "description": "Execute the readonly Linear graphql query to get the object",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "description": "The readonly Linear graphql query",
              "type": "string"
            },
            "variables": {
              "anyOf": [
                {
                  "additionalProperties": true,
                  "type": "object"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "The variables that can be passed into the query"
            }
          },
          "required": [
            "query"
          ]
        },
        "outputSchema": {
          "type": "object",
          "additionalProperties": true
        },
        "_meta": {
          "_fastmcp": {
            "tags": []
          }
        }
      },
      {
        "name": "execute_mutation_query",
        "description": "Execute the mutation Linear graphql query to get the object.\nImportant:\n- Use batch_create_or_update_issues tool to create or update issues.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "description": "The mutation Linear graphql query",
              "type": "string"
            },
            "variables": {
              "anyOf": [
                {
                  "additionalProperties": true,
                  "type": "object"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "The variables that can be passed into the query"
            }
          },
          "required": [
            "query"
          ]
        },
        "outputSchema": {
          "type": "object",
          "additionalProperties": true
        },
        "_meta": {
          "_fastmcp": {
            "tags": []
          }
        }
      },
      {
        "name": "batch_create_or_update_issues",
        "description": "Create or update multiple issues at once.\nExamples:\n```\n\nbatch_create_or_update_issues(operation: \"create\", new_issues: [\n    {title: \"New Title\", teamId: \"123\"},\n    {title: \"New Title 2\", teamId: \"456\"}\n])\n\nbatch_create_or_update_issues(operation: \"update\", ids: [\"123\", \"456\"], common_update: {title: \"New Title\"})\n\nbatch_create_or_update_issues(operation: \"update\", ids: [\"123\", \"456\"], specific_updates: {\n    \"123\": {title: \"New Title\"},\n    \"456\": {title: \"New Title 2\"}\n})\n\nbatch_create_or_update_issues(\n    operation: \"update\",\n    ids: [\"123\", \"456\", \"789\"],\n    common_update: {description: \"New Description\"},\n    specific_updates: {\n        \"123\": {title: \"New Title\"},\n        \"456\": {title: \"New Title 2\"}\n    }\n)\n```",
        "inputSchema": {
          "type": "object",
          "properties": {
            "operation": {
              "enum": [
                "create",
                "update"
              ],
              "type": "string"
            },
            "new_issues": {
              "default": [],
              "description": "To create",
              "items": {
                "$ref": "#/$defs/IssueInput"
              },
              "type": "array"
            },
            "ids": {
              "default": [],
              "description": "To update",
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "common_update": {
              "$ref": "#/$defs/IssueInput",
              "default": null,
              "description": "Optional shared update applicable to all issues IDs"
            },
            "specific_updates": {
              "additionalProperties": {
                "$ref": "#/$defs/IssueInput"
              },
              "default": {},
              "description": "Optional map of issue IDs to individual updates. Prefer using `common_update` for most issues and only use `specific_updates` for issues that require different values.",
              "type": "object"
            }
          },
          "required": [
            "operation"
          ],
          "$defs": {
            "IssueInput": {
              "properties": {
                "addedLabelIds": {
                  "anyOf": [
                    {
                      "items": {
                        "type": "string"
                      },
                      "type": "array"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "issue label IDs to be added to this issue."
                },
                "assigneeId": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "ID of user to assign the issue to."
                },
                "autoClosedByParentClosing": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null
                },
                "cycleId": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null
                },
                "description": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "In markdown format."
                },
                "dueDate": {
                  "anyOf": [
                    {
                      "format": "date",
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null
                },
                "estimate": {
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null
                },
                "labelIds": {
                  "anyOf": [
                    {
                      "items": {
                        "type": "string"
                      },
                      "type": "array"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null
                },
                "lastAppliedTemplateId": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null
                },
                "parentId": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null
                },
                "priority": {
                  "anyOf": [
                    {
                      "enum": [
                        0,
                        1,
                        2,
                        3,
                        4
                      ],
                      "type": "integer"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "0 = No priority, 1 = Urgent, 2 = High, 3 = Normal, 4 = Low."
                },
                "prioritySortOrder": {
                  "anyOf": [
                    {
                      "type": "number"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "The position of the issue related to other issues, when ordered by priority."
                },
                "projectId": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null
                },
                "projectMilestoneId": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null
                },
                "removedLabelIds": {
                  "anyOf": [
                    {
                      "items": {
                        "type": "string"
                      },
                      "type": "array"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "issue label IDs to be removed from this issue"
                },
                "slaType": {
                  "anyOf": [
                    {
                      "enum": [
                        "BUSINESS_DAYS",
                        "CALENDAR_DAYS"
                      ],
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "SLA day count type for the issue"
                },
                "snoozedById": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "ID of user who snoozed the issue"
                },
                "snoozedUntilAt": {
                  "anyOf": [
                    {
                      "format": "date-time",
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Time until an issue will be snoozed in Triage view."
                },
                "sortOrder": {
                  "anyOf": [
                    {
                      "type": "number"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Position related to other issues."
                },
                "stateId": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null
                },
                "subIssueSortOrder": {
                  "anyOf": [
                    {
                      "type": "number"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Position of the issue in parent's sub-issue list."
                },
                "subscriberIds": {
                  "anyOf": [
                    {
                      "items": {
                        "type": "string"
                      },
                      "type": "array"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null
                },
                "title": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null
                },
                "trashed": {
                  "anyOf": [
                    {
                      "type": "boolean"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null
                },
                "teamId": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Required for creating an issue."
                }
              },
              "type": "object"
            }
          }
        },
        "outputSchema": {
          "type": "object",
          "additionalProperties": true
        },
        "_meta": {
          "_fastmcp": {
            "tags": []
          }
        }
      }
    ]
  },
  "gcal": {
    "tools": [
      {
        "name": "query_calendar_tables",
        "description": "Fetch data from a table in the calendar database.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "table_name": {
              "enum": [
                "calendar_notifications",
                "calendars",
                "default_reminders"
              ],
              "type": "string"
            },
            "time_period": {
              "anyOf": [
                {
                  "enum": [
                    "yesterday",
                    "today",
                    "tomorrow",
                    "this_week",
                    "next_week"
                  ],
                  "type": "string"
                },
                {
                  "$ref": "#/$defs/TimeRange"
                }
              ],
              "description": "The period to filter by. Either a PresetTimePeriod or a TimeRange with bothtime_min and time_max. Prefer `PresetTimePeriod` when supported."
            },
            "calendar_id": {
              "default": "",
              "description": "Calendar ID to filter by. Leave blank to use current user's calendar.",
              "type": "string"
            },
            "timezone": {
              "default": "",
              "description": "User's timezone. Leave blank to use user's timezone",
              "examples": [
                "America/Los_Angeles"
              ],
              "type": "string"
            }
          },
          "required": [
            "table_name",
            "time_period"
          ],
          "$defs": {
            "TimeRange": {
              "description": "Time min and max should be naive (not timezone aware). They will be interpreted\nin the given `timezone` parameter, e.g. 2025-01-01 12:00:00",
              "properties": {
                "time_min": {
                  "description": "The start time to filter by, in RFC3339",
                  "format": "date-time",
                  "type": "string"
                },
                "time_max": {
                  "description": "The end time to filter by, in RFC3339",
                  "format": "date-time",
                  "type": "string"
                }
              },
              "required": [
                "time_min",
                "time_max"
              ],
              "type": "object"
            }
          }
        },
        "outputSchema": {
          "type": "object",
          "properties": {
            "result": {
              "type": "string"
            }
          },
          "required": [
            "result"
          ],
          "x-fastmcp-wrap-result": true
        },
        "_meta": {
          "_fastmcp": {
            "tags": []
          }
        }
      },
      {
        "name": "get_free_slots",
        "description": "Get the free slots for the given calendar IDs.\nReturns one row per slice, plus two Boolean flags\n- free_for_all: boolean - nobody has any conflicting event\n- free_for_confirmed_events: boolean - nobody has an accepted/tentative conflicting event\nRows where both flags = FALSE are filtered out",
        "inputSchema": {
          "type": "object",
          "properties": {
            "calendar_ids": {
              "description": "The calendar IDs to get free slots for.",
              "examples": [
                [
                  "primary",
                  "testuser@squareup.com",
                  "testuser@block.xyz"
                ]
              ],
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "time_period": {
              "anyOf": [
                {
                  "enum": [
                    "yesterday",
                    "today",
                    "tomorrow",
                    "this_week",
                    "next_week"
                  ],
                  "type": "string"
                },
                {
                  "$ref": "#/$defs/TimeRange"
                }
              ],
              "description": "The period to filter by. Either a PresetTimePeriod or a TimeRange with bothtime_min and time_max. Prefer `PresetTimePeriod` when supported."
            },
            "input_timezone": {
              "default": "",
              "type": "string"
            },
            "display_timezone": {
              "default": "",
              "type": "string"
            }
          },
          "required": [
            "calendar_ids",
            "time_period"
          ],
          "$defs": {
            "TimeRange": {
              "description": "Time min and max should be naive (not timezone aware). They will be interpreted\nin the given `timezone` parameter, e.g. 2025-01-01 12:00:00",
              "properties": {
                "time_min": {
                  "description": "The start time to filter by, in RFC3339",
                  "format": "date-time",
                  "type": "string"
                },
                "time_max": {
                  "description": "The end time to filter by, in RFC3339",
                  "format": "date-time",
                  "type": "string"
                }
              },
              "required": [
                "time_min",
                "time_max"
              ],
              "type": "object"
            }
          }
        },
        "outputSchema": {
          "type": "object",
          "properties": {
            "result": {
              "type": "string"
            }
          },
          "required": [
            "result"
          ],
          "x-fastmcp-wrap-result": true
        },
        "_meta": {
          "_fastmcp": {
            "tags": []
          }
        }
      },
      {
        "name": "get_user_and_calendar_context",
        "description": "This tool is deprecated. Stop using it.",
        "inputSchema": {
          "type": "object",
          "properties": {}
        },
        "outputSchema": {
          "type": "object",
          "properties": {
            "result": {
              "type": "string"
            }
          },
          "required": [
            "result"
          ],
          "x-fastmcp-wrap-result": true
        },
        "_meta": {
          "_fastmcp": {
            "tags": []
          }
        }
      },
      {
        "name": "get_calendar_events",
        "description": "Get calendar events",
        "inputSchema": {
          "type": "object",
          "properties": {
            "time_period": {
              "anyOf": [
                {
                  "enum": [
                    "yesterday",
                    "today",
                    "tomorrow",
                    "this_week",
                    "next_week"
                  ],
                  "type": "string"
                },
                {
                  "$ref": "#/$defs/TimeRange"
                }
              ],
              "description": "Period to filter by. Either a PresetTimePeriod or a TimeRange with both time_min and time_max.Use preset time periods when supported."
            },
            "calendar_id": {
              "default": "",
              "description": "Calendar ID to filter by. Leave blank to use current user's calendar.",
              "examples": [
                "",
                "primary",
                "testuser@block.xyz",
                "other@example.com"
              ],
              "type": "string"
            },
            "timezone": {
              "default": "",
              "description": "User's timezone. Leave blank to use user's timezone",
              "examples": [
                "America/Los_Angeles"
              ],
              "type": "string"
            },
            "event_ids": {
              "default": [],
              "description": "Event IDs to filter by. If empty, all events will be returned.",
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "event_status": {
              "default": "",
              "description": "Event status to filter by. If empty, all events will be returned.",
              "enum": [
                "confirmed",
                "tentative",
                "cancelled",
                ""
              ],
              "type": "string"
            },
            "include_attendees_info": {
              "default": false,
              "description": "Whether to include list of attendees information",
              "type": "boolean"
            },
            "meeting_state": {
              "default": "all",
              "enum": [
                "completed",
                "upcoming",
                "in progress",
                "all"
              ],
              "type": "string"
            }
          },
          "required": [
            "time_period"
          ],
          "$defs": {
            "TimeRange": {
              "description": "Time min and max should be naive (not timezone aware). They will be interpreted\nin the given `timezone` parameter, e.g. 2025-01-01 12:00:00",
              "properties": {
                "time_min": {
                  "description": "The start time to filter by, in RFC3339",
                  "format": "date-time",
                  "type": "string"
                },
                "time_max": {
                  "description": "The end time to filter by, in RFC3339",
                  "format": "date-time",
                  "type": "string"
                }
              },
              "required": [
                "time_min",
                "time_max"
              ],
              "type": "object"
            }
          }
        },
        "outputSchema": {
          "type": "object",
          "properties": {
            "result": {
              "type": "string"
            }
          },
          "required": [
            "result"
          ],
          "x-fastmcp-wrap-result": true
        },
        "_meta": {
          "_fastmcp": {
            "tags": []
          }
        }
      },
      {
        "name": "create_calendar_event",
        "description": "Create a new calendar event.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "title": {
              "type": "string"
            },
            "start_time": {
              "format": "date-time",
              "type": "string"
            },
            "end_time": {
              "format": "date-time",
              "type": "string"
            },
            "user_calendarID": {
              "default": "",
              "type": "string"
            },
            "timezone": {
              "default": "",
              "description": "The timezone of the user, e.g. 'America/Los_Angeles'",
              "type": "string"
            },
            "description": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null
            },
            "attendees": {
              "anyOf": [
                {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                {
                  "type": "null"
                }
              ],
              "default": null
            }
          },
          "required": [
            "title",
            "start_time",
            "end_time"
          ]
        },
        "outputSchema": {
          "type": "object",
          "additionalProperties": true
        },
        "_meta": {
          "_fastmcp": {
            "tags": []
          }
        }
      },
      {
        "name": "update_calendar_event",
        "description": "Update an existing calendar event.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "event_id": {
              "type": "string"
            },
            "start_time": {
              "format": "date-time",
              "type": "string"
            },
            "end_time": {
              "format": "date-time",
              "type": "string"
            },
            "timezone": {
              "default": "",
              "description": "The timezone of the user, e.g. 'America/Los_Angeles'",
              "type": "string"
            },
            "calendar_id": {
              "default": "primary",
              "type": "string"
            },
            "title": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null
            },
            "description": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null
            },
            "attendees": {
              "anyOf": [
                {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                {
                  "type": "null"
                }
              ],
              "default": null
            }
          },
          "required": [
            "event_id",
            "start_time",
            "end_time"
          ]
        },
        "outputSchema": {
          "type": "object",
          "additionalProperties": true
        },
        "_meta": {
          "_fastmcp": {
            "tags": []
          }
        }
      },
      {
        "name": "delete_calendar_event",
        "description": "Delete a calendar event.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "event_id": {
              "type": "string"
            },
            "calendar_id": {
              "default": "primary",
              "type": "string"
            }
          },
          "required": [
            "event_id"
          ]
        },
        "outputSchema": {
          "type": "object",
          "additionalProperties": true
        },
        "_meta": {
          "_fastmcp": {
            "tags": []
          }
        }
      },
      {
        "name": "lookup_email",
        "description": "Look up emails by name. Returns formatted person\nemails with disambiguation options for multiple matches.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "names": {
              "description": "Names or approximate names of people to search for. Can include full names, partial names.",
              "examples": [
                [
                  "Nathan Thillairajah"
                ],
                [
                  "Nathan",
                  "nthillairajah"
                ],
                [
                  "John Smith",
                  "Jane Doe"
                ]
              ],
              "items": {
                "type": "string"
              },
              "type": "array"
            }
          },
          "required": [
            "names"
          ]
        },
        "outputSchema": {
          "type": "object",
          "properties": {
            "result": {
              "type": "string"
            }
          },
          "required": [
            "result"
          ],
          "x-fastmcp-wrap-result": true
        },
        "_meta": {
          "_fastmcp": {
            "tags": []
          }
        }
      }
    ]
  },
  "snowflake": {
    "tools": [
      {
        "name": "set_config",
        "description": "Set a configuration value for the Snowflake client. This tool allows setting various\n    configuration parameters that control client behavior.\n\n    Common configuration keys:\n    - limit: Maximum number of rows to return in query results (integer)\n    - timeout: Default query timeout in seconds (integer)\n    - warehouse: Default warehouse to use for query execution (string)\n\n    Examples:\n    1. Set query result limit:\n        set_config(\"limit\", 200)\n        \n    2. Set default timeout:\n        set_config(\"timeout\", 600)\n        \n    3. Set default warehouse:\n        set_config(\"warehouse\", \"ADHOC__XLARGE\")\n\n    Args:\n        key: Configuration key to set\n        value: Value to set for the configuration\n        description: Optional description of what this configuration does\n\n    Returns:\n        Dictionary containing operation status and the new configuration value\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "key": {
              "title": "Key",
              "type": "string"
            },
            "value": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                },
                {
                  "type": "number"
                },
                {
                  "type": "boolean"
                }
              ],
              "title": "Value"
            },
            "description": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Description"
            }
          },
          "required": [
            "key",
            "value"
          ],
          "title": "set_configArguments"
        },
        "outputSchema": {
          "type": "object",
          "properties": {
            "result": {
              "additionalProperties": true,
              "title": "Result",
              "type": "object"
            }
          },
          "required": [
            "result"
          ],
          "title": "set_configOutput"
        }
      },
      {
        "name": "get_config",
        "description": "Get the current configuration value(s) for the Snowflake client.\n    If no key is provided, returns all configuration values. Version is available in metadata.\n\n    Examples:\n    1. Get all configuration (includes metadata with version):\n        get_config()\n        # Returns: {\n        #   \"username\": \"user@example.com\",\n        #   \"account\": \"square\",\n        #   \"warehouse\": \"COMPUTE_WH\",\n        #   \"limit\": 100,\n        #   \"metadata\": {\"source\": \"mcp_snowflake\", \"version\": \"1.0.0\"}\n        # }\n        \n    2. Get specific config value:\n        get_config(\"limit\")\n        # Returns: {\"limit\": 100}\n        \n    3. Get metadata (includes version):\n        get_config(\"metadata\")\n        # Returns: {\"metadata\": {\"source\": \"mcp_snowflake\", \"version\": \"1.0.0\"}}\n\n    Args:\n        key: Optional configuration key to get. If not provided, returns all config.\n\n    Returns:\n        Dictionary containing the requested configuration value(s)\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "key": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Key"
            }
          },
          "title": "get_configArguments"
        },
        "outputSchema": {
          "type": "object",
          "properties": {
            "result": {
              "additionalProperties": true,
              "title": "Result",
              "type": "object"
            }
          },
          "required": [
            "result"
          ],
          "title": "get_configOutput"
        }
      },
      {
        "name": "fetch_context",
        "description": "Retrieve context information for Snowflake database objects. This tool fetches metadata and usage context\n    for the specified database, schema, or table. Always call this tool before executing queries to ensure\n    you have the proper context for the data you're working with.\n\n    Context Definition:\n    Context refers to descriptive information about Snowflake objects including:\n    - Purpose and contents of the object\n    - Usage patterns and best practices\n    - Data freshness and update frequency\n    - Related objects and dependencies\n    - Access patterns and common queries\n\n    Examples:\n    1. Fetch database context:\n        fetch_context(database_name=\"ANALYTICS_DB\")\n        # Returns context about the analytics database purpose and contents\n\n    2. Fetch schema context:\n        fetch_context(database_name=\"ANALYTICS_DB\", schema_name=\"SALES\")\n        # Returns context about the sales schema and its relation to analytics\n\n    3. Fetch table context:\n        fetch_context(database_name=\"ANALYTICS_DB\", schema_name=\"SALES\", table_name=\"TRANSACTIONS\")\n        # Returns detailed context about the transactions table structure and usage\n\n    Args:\n        database_name: Name of the Snowflake database\n        schema_name: Optional schema name within the database\n        table_name: Optional table name within the schema\n\n    Returns:\n        Dictionary containing context information including descriptions, usage patterns, and metadata\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "database_name": {
              "title": "Database Name",
              "type": "string"
            },
            "schema_name": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Schema Name"
            },
            "table_name": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Table Name"
            }
          },
          "required": [
            "database_name"
          ],
          "title": "fetch_contextArguments"
        },
        "outputSchema": {
          "type": "object",
          "properties": {
            "result": {
              "additionalProperties": true,
              "title": "Result",
              "type": "object"
            }
          },
          "required": [
            "result"
          ],
          "title": "fetch_contextOutput"
        }
      },
      {
        "name": "execute_query",
        "description": "Execute one or more SELECT queries in Snowflake with optional connection parameters. \n    Supports both single query execution (backward compatible) and parallel execution of multiple queries.\n    \n    For best results follow the instructions for Snowflake Queries:\n    1. CONTEXT CHECKING REQUIREMENTS:\n       Context checking is ONLY required for queries that access user data from specific tables/views.\n       \n       QUERIES THAT REQUIRE CONTEXT CHECKING:\n       - SELECT FROM specific tables/views (e.g., \"SELECT * FROM my_database.my_schema.my_table\")\n       - Queries with JOINs across databases/schemas\n       - Queries that reference user data structures\n       \n       QUERIES THAT DO NOT REQUIRE CONTEXT CHECKING:\n       - Account-level metadata queries: SHOW WAREHOUSES, SHOW DATABASES, SHOW ROLES\n       - Database exploration queries: SHOW TABLES IN DATABASE, SHOW SCHEMAS IN DATABASE  \n       - Administrative commands: DESCRIBE TABLE, USE DATABASE, EXPLAIN\n       - System function calls: SELECT CURRENT_USER(), SELECT CURRENT_WAREHOUSE()\n       \n       WHEN CONTEXT IS REQUIRED:\n       - Check context for ALL databases involved in your SELECT FROM queries\n       - Include utility databases you plan to query from (like SNOWFLAKE_USAGE)\n       - Check context for cross-database references\n       \n       Example requiring context:\n       ```\n       Query: SELECT * FROM SNOWFLAKE_USAGE.PUBLIC.QUERY_HISTORY\n       Required context checks:\n       1. fetch_context(database_name=\"SNOWFLAKE_USAGE\")\n       2. fetch_context(database_name=\"SNOWFLAKE_USAGE\", schema_name=\"PUBLIC\")\n       3. fetch_context(database_name=\"SNOWFLAKE_USAGE\", schema_name=\"PUBLIC\", table_name=\"QUERY_HISTORY\")\n       ```\n       \n       Example NOT requiring context:\n       ```\n       Query: SHOW WAREHOUSES LIKE 'TEMP%'\n       No context needed - this is an account-level metadata query\n       ```\n\n    2. QUERY GUIDELINES:\n       - Use only SELECT statements for data retrieval\n       - Always specify database and schema explicitly in queries\n       - Ensure you have proper access to all databases in your query\n       - When using the execute_query tool, make sure to remove the comments from the beginning of the query before executing it.\n\n    Examples:\n    1. Simple query with default account:\n        execute_query(\"SELECT COUNT(*) FROM SALES.TRANSACTIONS\")\n        \n    2. Query with specific database and schema:\n        execute_query(\n            \"SELECT product_id, SUM(quantity) FROM INVENTORY.STOCK GROUP BY product_id\",\n            database_name=\"WAREHOUSE_DB\",\n            schema_name=\"INVENTORY\"\n        )\n        \n    3. Query with custom timeout:\n        execute_query(\n            \"SELECT * FROM LARGE_TABLE WHERE date = CURRENT_DATE()\",\n            timeout_secs=600\n        )\n\n    4. Query with different account:\n        execute_query(\n            \"SELECT * FROM USERS\",\n            account=\"squarestaging\",\n            database_name=\"AUTH_DB\"\n        )\n    \n    5. Query with specific warehouse:\n        execute_query(\n            \"SELECT * FROM LARGE_TABLE WHERE complex_condition = true\",\n            warehouse=\"ADHOC__XLARGE\"\n        )\n    \n    6. Multiple queries in parallel:\n        execute_query([\n            \"SELECT COUNT(*) FROM ORDERS\",\n            \"SELECT COUNT(*) FROM CUSTOMERS\",\n            \"SELECT COUNT(*) FROM PRODUCTS\"\n        ])\n    \n    7. Multiple queries with different configurations:\n        execute_query([\n            {\n                \"query\": \"SELECT * FROM PROD_DATA\",\n                \"database_name\": \"PROD_DB\"\n            },\n            {\n                \"query\": \"SELECT * FROM STAGING_DATA\",\n                \"database_name\": \"STAGING_DB\",\n                \"warehouse\": \"ADHOC__LARGE\"\n            }\n        ])\n\n    Args:\n        query: Either:\n            - A single SQL SELECT query string\n            - A list of query strings for parallel execution\n            - A list of query configurations (dicts) with query and optional overrides\n        account: Snowflake account identifier (defaults to \"square\")\n        database_name: Target Snowflake database for the query\n        schema_name: Target schema within the database\n        timeout_secs: Query timeout in seconds (defaults to 300)\n        warehouse: Snowflake warehouse to use for execution (defaults to configured warehouse or ADHOC__MEDIUM)\n        max_workers: Maximum number of parallel workers (defaults to 5)\n    \n    Returns:\n        Dictionary containing:\n        - For single query: Standard query results, execution status, and metadata\n        - For multiple queries: Results array with one result dict per query, plus summary statistics\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "items": {},
                  "type": "array"
                }
              ],
              "title": "Query"
            },
            "account": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": "square",
              "title": "Account"
            },
            "database_name": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Database Name"
            },
            "schema_name": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Schema Name"
            },
            "timeout_secs": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": 300,
              "title": "Timeout Secs"
            },
            "warehouse": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Warehouse"
            },
            "max_workers": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": 5,
              "title": "Max Workers"
            }
          },
          "required": [
            "query"
          ],
          "title": "execute_queryArguments"
        },
        "outputSchema": {
          "type": "object",
          "properties": {
            "result": {
              "additionalProperties": true,
              "title": "Result",
              "type": "object"
            }
          },
          "required": [
            "result"
          ],
          "title": "execute_queryOutput"
        }
      },
      {
        "name": "submit_feedback",
        "description": "Submit feedback EXCLUSIVELY for the Snowflake Extension and its features. This tool is strictly for:\n    \n    1. Snowflake Query & Data Access:\n       - Query execution and performance issues\n       - Problems with SELECT statements\n       - Database, schema, or table access challenges\n       - Warehouse configuration concerns\n    \n    2. Snowflake Extension Tools:\n       - Issues with execute_query tool\n       - Feedback about fetch_context functionality\n       - Problems with add_context or delete_context\n       - Suggestions for search or find_linked_contexts\n       - Session summary tool improvements\n    \n    3. Snowflake Integration Features:\n       - Context management system feedback\n       - Connection and authentication issues\n       - Timeout and performance settings\n       - Result formatting and display\n    \n    DO NOT USE THIS TOOL FOR:\n     General Goose application feedback\n     Other extension-related feedback\n     Non-Snowflake database questions\n     UI/UX suggestions unrelated to Snowflake\n    \n    Your feedback is stored in SNOWFLAKE_USAGE.PUBLIC.GOOSE_SNOWFLAKE_FEATURE_REQUESTS\n    and will be reviewed by the Snowflake team.\n\n    Examples:\n    1.  Valid Snowflake Extension Feedback:\n        ```\n        \"The execute_query tool is timing out on large result sets\"\n        \"Can we add support for Snowflake stored procedure execution?\"\n        \"fetch_context should show last update timestamp for tables\"\n        \"Session summary tool should include query cost estimates\"\n        ```\n    \n    2.  Invalid (Non-Snowflake) Feedback:\n        ```\n        \"The Goose chat interface needs dark mode\"          # Use general Goose feedback channels\n        \"Add support for MongoDB queries\"                   # Not Snowflake-related\n        \"The file editor tool is not working\"              # Use developer extension feedback\n        \"Improve the response formatting in chat\"          # General Goose feedback\n        ```\n\n    Args:\n        feedback: Your specific feedback about Snowflake extension features, tools, or functionality\n        is_snowflake_related: Flag indicating if the feedback is specifically about Snowflake functionality.\n                            Set to False for non-Snowflake feedback to receive guidance on proper channels.\n\n    Returns:\n        Dictionary containing submission status and tracking information\n\n    Raises:\n        ValueError: If attempting to submit non-Snowflake feedback (is_snowflake_related=False)\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "feedback": {
              "title": "Feedback",
              "type": "string"
            },
            "is_snowflake_related": {
              "default": true,
              "title": "Is Snowflake Related",
              "type": "boolean"
            }
          },
          "required": [
            "feedback"
          ],
          "title": "submit_feedbackArguments"
        },
        "outputSchema": {
          "type": "object",
          "properties": {
            "result": {
              "additionalProperties": true,
              "title": "Result",
              "type": "object"
            }
          },
          "required": [
            "result"
          ],
          "title": "submit_feedbackOutput"
        }
      },
      {
        "name": "add_context",
        "description": "Add descriptive context to Snowflake objects to improve future query assistance. This tool helps\n    build a knowledge base about your data structures and their relationships.\n\n    To ensure optimal results when managing context, please follow these guidelines:\n        1. Check Existing Context:\n            - Always use fetch_context to review the current context before introducing any new context.\n        2. Avoid Redundancy and Conflicts:\n            - It is crucial to prevent the inclusion of redundant or conflicting contexts, as these can lead to confusion.\n        3. Compare Before Adding:\n            - Before adding new context, compare it with the existing context to ensure there are no redundant or duplicate entries.\n            - If similar context already exists, inform the requester and refrain from adding it again.\n        4. Handle Conflicting Contexts:\n            - Do not add new context if it conflicts with existing context, as this can cause confusion.\n            - If a conflict arises, ask the requester to delete the conflicting existing context before adding the new one.\n\n    Context Definition:\n    Context is metadata that describes:\n    - Purpose and contents of the object\n    - Data lineage and relationships\n    - Update frequency and patterns\n    - Common use cases and queries\n    - Access patterns and permissions\n    - Data quality expectations\n    - Business relevance and importance\n\n    Examples:\n    1. Add database context:\n        add_context(\n            \"This database contains all customer transaction data from 2020 onwards. \n            Data is refreshed daily at midnight UTC.\",\n            database_name=\"CUSTOMER_TRANSACTIONS\"\n        )\n\n    2. Add schema context:\n        add_context(\n            \"The RETAIL schema contains normalized tables for in-store purchases. \n            Join with CUSTOMER schema for demographic data.\",\n            database_name=\"SALES_DB\",\n            schema_name=\"RETAIL\"\n        )\n\n    3. Add table context:\n        add_context(\n            \"Daily aggregated sales metrics by product category. \n            Primary key is (date, category_id). Updated hourly.\",\n            database_name=\"ANALYTICS\",\n            schema_name=\"REPORTS\",\n            table_name=\"DAILY_SALES\"\n        )\n\n    4. Add migration context:\n        add_context(\n            \"This database is deprecated. Use ANALYTICS_V2 instead. \n            Migration deadline: 2024-12-31\",\n            database_name=\"OLD_ANALYTICS\"\n        )\n\n    Args:\n        context: Descriptive message about the object's purpose or contents\n        database_name: Name of the database to add context to\n        schema_name: Optional schema name to add context to\n        table_name: Optional table name to add context to\n\n    Returns:\n        Dictionary containing context addition status and confirmation\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "context": {
              "title": "Context",
              "type": "string"
            },
            "database_name": {
              "title": "Database Name",
              "type": "string"
            },
            "schema_name": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Schema Name"
            },
            "table_name": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Table Name"
            }
          },
          "required": [
            "context",
            "database_name"
          ],
          "title": "add_contextArguments"
        },
        "outputSchema": {
          "type": "object",
          "properties": {
            "result": {
              "additionalProperties": true,
              "title": "Result",
              "type": "object"
            }
          },
          "required": [
            "result"
          ],
          "title": "add_contextOutput"
        }
      },
      {
        "name": "delete_context",
        "description": "Remove a previously added context entry from Snowflake metadata. This will delete the specified\n    context from SNOWFLAKE_USAGE.PUBLIC.GOOSE_SNOWFLAKE_CONTEXT permanently.\n\n    Examples:\n    1. Delete outdated context:\n        delete_context(context_id=1234)\n        # Removes obsolete context about deprecated features\n        \n    2. Delete incorrect context:\n        delete_context(context_id=5678)\n        # Removes context with wrong information\n        \n    3. Delete duplicate context:\n        delete_context(context_id=9012)\n        # Removes redundant context entry\n\n    Args:\n        context_id: Unique identifier of the context to delete\n\n    Returns:\n        Dictionary containing deletion status and confirmation\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "context_id": {
              "title": "Context Id",
              "type": "integer"
            }
          },
          "required": [
            "context_id"
          ],
          "title": "delete_contextArguments"
        },
        "outputSchema": {
          "type": "object",
          "properties": {
            "result": {
              "additionalProperties": true,
              "title": "Result",
              "type": "object"
            }
          },
          "required": [
            "result"
          ],
          "title": "delete_contextOutput"
        }
      },
      {
        "name": "search",
        "description": "Search for Snowflake objects using keywords. This tool performs a text search across all stored\n    contexts to help locate relevant databases, schemas, or tables.\n\n    Context Definition:\n    The search looks through stored context information including:\n    - Object descriptions and purposes\n    - Usage patterns and relationships\n    - Business context and relevance\n    - Technical metadata and specifications\n    - Data quality and update information\n\n    Examples:\n    1. Search by domain:\n        search(\"sales, revenue, transactions\")\n        # Finds objects related to sales data\n        \n    2. Search by technical terms:\n        search(\"ETL, raw data, staging\")\n        # Finds data pipeline related objects\n        \n    3. Search by business context:\n        search(\"customer segmentation, demographics\")\n        # Finds customer analysis related objects\n        \n    4. Search with custom delimiter:\n        search(\"user|profile|preferences\", delimiter=\"|\")\n        # Finds user-related objects using | as delimiter\n\n    Args:\n        keywords: Search terms (e.g., \"GPV, registry, data\")\n        delimiter: Character used to separate multiple keywords (defaults to comma)\n\n    Returns:\n        Dictionary containing matching objects with their context and metadata\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "keywords": {
              "title": "Keywords",
              "type": "string"
            },
            "delimiter": {
              "default": ",",
              "title": "Delimiter",
              "type": "string"
            }
          },
          "required": [
            "keywords"
          ],
          "title": "searchArguments"
        },
        "outputSchema": {
          "type": "object",
          "properties": {
            "result": {
              "additionalProperties": true,
              "title": "Result",
              "type": "object"
            }
          },
          "required": [
            "result"
          ],
          "title": "searchOutput"
        }
      },
      {
        "name": "find_linked_contexts",
        "description": "Retrieve all related context entries for a Snowflake object and its parent objects. This tool provides\n    a hierarchical view of contexts, showing both direct and inherited context information.\n\n    Context Definition:\n    Linked contexts include:\n    - Direct context: Information specifically about the requested object\n    - Inherited context: Information from parent objects\n    - Related context: Information about dependencies and relationships\n    - Usage context: Common patterns and best practices\n    - Business context: Relevance and importance to business processes\n\n    Examples:\n    1. Find all database contexts:\n        find_linked_contexts(database_name=\"ANALYTICS_DB\")\n        # Returns all contexts related to the analytics database\n        \n    2. Find schema and database contexts:\n        find_linked_contexts(\n            database_name=\"ANALYTICS_DB\",\n            schema_name=\"MARKETING\"\n        )\n        # Returns contexts for marketing schema and its parent database\n        \n    3. Find complete context hierarchy:\n        find_linked_contexts(\n            database_name=\"ANALYTICS_DB\",\n            schema_name=\"MARKETING\",\n            table_name=\"CAMPAIGNS\"\n        )\n        # Returns contexts for campaigns table, marketing schema, and analytics database\n        \n    4. Find related contexts:\n        find_linked_contexts(database_name=\"PROD_DB\")\n        # Returns contexts including related staging and development databases\n\n    Args:\n        database_name: Name of the database to search\n        schema_name: Optional schema name to narrow the search\n        table_name: Optional table name for most specific results\n\n    Returns:\n        Dictionary containing:\n        - List of context entries with full metadata\n        - Each entry includes: context_id, database_name, schema_name, table_name,\n          context, author, created_at, and context_level\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "database_name": {
              "title": "Database Name",
              "type": "string"
            },
            "schema_name": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Schema Name"
            },
            "table_name": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Table Name"
            }
          },
          "required": [
            "database_name"
          ],
          "title": "find_linked_contextsArguments"
        },
        "outputSchema": {
          "type": "object",
          "properties": {
            "result": {
              "additionalProperties": true,
              "title": "Result",
              "type": "object"
            }
          },
          "required": [
            "result"
          ],
          "title": "find_linked_contextsOutput"
        }
      },
      {
        "name": "analyze_query",
        "description": "Analyze a SQL query to extract referenced objects without executing it. This tool uses static\n    analysis (SQLGlot) to parse the query and identify all tables, views, and databases referenced.\n    \n    This is useful for:\n    - Understanding query dependencies before execution\n    - Identifying which contexts to fetch\n    - Detecting cross-database queries\n    - Query planning and optimization\n    \n    Features:\n    - Fast analysis (no Snowflake connection required)\n    - Handles complex queries: JOINs, subqueries, CTEs\n    - Identifies cross-database references\n    - Excludes temporary objects (CTEs)\n    \n    Examples:\n    1. Analyze a simple query:\n        analyze_query(\"SELECT * FROM users\")\n        # Returns: objects=[{table: \"users\"}], count=1\n        \n    2. Analyze a JOIN across databases:\n        analyze_query(\n            \"SELECT o.*, c.name \"\n            \"FROM orders.public.orders o \"\n            \"JOIN customers.public.customers c ON o.customer_id = c.id\"\n        )\n        # Returns: objects=[\n        #   {database: \"orders\", schema: \"public\", table: \"orders\"},\n        #   {database: \"customers\", schema: \"public\", table: \"customers\"}\n        # ], has_cross_database=True\n        \n    3. Analyze query with CTE:\n        analyze_query(\n            \"WITH active_users AS (SELECT * FROM users WHERE active = true) \"\n            \"SELECT * FROM active_users\"\n        )\n        # Returns: objects=[{table: \"users\"}], ctes=[\"ACTIVE_USERS\"]\n    \n    Args:\n        query: SQL query string to analyze\n        \n    Returns:\n        Dictionary containing:\n        - objects: List of referenced database objects\n        - count: Number of unique objects\n        - has_cross_database: Boolean indicating if query spans multiple databases\n        - databases: List of database names referenced\n        - ctes: List of CTE (WITH clause) names detected\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "title": "Query",
              "type": "string"
            }
          },
          "required": [
            "query"
          ],
          "title": "analyze_queryArguments"
        },
        "outputSchema": {
          "type": "object",
          "properties": {
            "result": {
              "additionalProperties": true,
              "title": "Result",
              "type": "object"
            }
          },
          "required": [
            "result"
          ],
          "title": "analyze_queryOutput"
        }
      },
      {
        "name": "check_permissions",
        "description": "Check if you have permission to execute a query or access tables without actually running them.\n    This tool uses Snowflake's EXPLAIN command to validate permissions, object existence, and syntax.\n    \n    **Provide EITHER 'query' OR 'tables', not both.**\n    \n    This is useful for:\n    - Pre-execution validation (avoid expensive failed queries)\n    - Bulk table access checking\n    - Permission troubleshooting\n    - Query development and testing\n    - Access auditing\n    \n    What it checks:\n    - User has SELECT/INSERT/UPDATE/DELETE permissions\n    - All referenced objects exist\n    - Query syntax is valid (for queries)\n    - User can access all databases/schemas\n    \n    Note: Uses EXPLAIN so it's safe and fast (no actual query execution)\n    \n    Examples:\n    1. Check query permissions:\n        check_permissions(query=\"SELECT * FROM sensitive_table\")\n        # Returns: {has_permission: False, error: \"Object does not exist or not authorized\"}\n        \n    2. Check multiple table access (detailed per-table results):\n        check_permissions(tables=[\n            \"SNOWFLAKE_USAGE.ACCOUNT_USAGE.QUERY_HISTORY\",\n            \"ANALYTICS.PUBLIC.USERS\"\n        ])\n        # Returns: {\n        #   has_permission: True/False,\n        #   tables_checked: [...],\n        #   results: {\n        #     \"table1\": {has_permission: True, error: None, error_type: None},\n        #     \"table2\": {has_permission: False, error: \"...\", error_type: \"object_not_found\"}\n        #   },\n        #   summary: {total: 2, passed: 1, failed: 1, failed_tables: [\"table2\"]}\n        # }\n        \n    3. Verify before expensive query:\n        perm = check_permissions(query=\"SELECT * FROM huge_table WHERE year = 2024\")\n        if perm[\"has_permission\"]:\n            execute_query(\"SELECT * FROM huge_table WHERE year = 2024\")\n        else:\n            print(f\"Permission denied: {perm['error']}\")\n    \n    Args:\n        query: SQL query to check permissions for (mutually exclusive with tables)\n        tables: List of fully qualified table names to check (mutually exclusive with query)\n        \n    Returns:\n        For query parameter:\n        - has_permission: Boolean\n        - error: Error message if denied\n        - error_type: Category of error\n        \n        For tables parameter (detailed per-table results):\n        - has_permission: Boolean (True only if ALL tables pass)\n        - tables_checked: List of tables checked\n        - results: Dict mapping each table to {has_permission, error, error_type}\n        - summary: Dict with total, passed, failed counts and failed_tables list\n        - error: Overall error message if any failed\n        - error_type: Error category\n    ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Query"
            },
            "tables": {
              "anyOf": [
                {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Tables"
            }
          },
          "title": "check_permissionsArguments"
        },
        "outputSchema": {
          "type": "object",
          "properties": {
            "result": {
              "additionalProperties": true,
              "title": "Result",
              "type": "object"
            }
          },
          "required": [
            "result"
          ],
          "title": "check_permissionsOutput"
        }
      }
    ]
  },
  "slack": {
    "tools": [
      {
        "name": "get_channel_messages",
        "description": "Get latest messages from a list of Slack channels (public, private), mpims, DMs, or threads, filtered by date.\nOnly one of `channel_id_or_dm_id`, `channel_name`, or `dm_username` should be provided for each channel.\n\nFor DMs, use either the DM channel ID or the other person's Slack username.\n\nUse `search_messages` for advanced filtering and relevance sorting. For filtering messages by a topic\nor query terms, you MUST use `search_messages` tool.\n\nOnly one of `after_date`, `newer_than`, or `on` can be provided.\nProvide `user_timezone` when `newer_than` is provided.\n\nReturns:\n    str: Formatted response with messages for each channel with format:",
        "inputSchema": {
          "type": "object",
          "properties": {
            "channels": {
              "description": "List of Slack channels/DMs to retrieve messages from",
              "items": {
                "$ref": "#/$defs/ChannelIdentifier"
              },
              "type": "array"
            },
            "messages_to_retrieve": {
              "default": 30,
              "description": "Max is 100.",
              "type": "integer"
            },
            "after_date": {
              "anyOf": [
                {
                  "format": "date",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Get messages after this date"
            },
            "before_date": {
              "anyOf": [
                {
                  "format": "date",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Get messages before this date"
            },
            "newer_than": {
              "anyOf": [
                {
                  "format": "duration",
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Get messages from the last `newer_than` period"
            },
            "on": {
              "anyOf": [
                {
                  "format": "date",
                  "type": "string"
                },
                {
                  "enum": [
                    "today",
                    "yesterday"
                  ],
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Get messages on this specific date, today's or yesterday's date"
            },
            "team_id": {
              "default": "",
              "description": "Workspace ID (required for org tokens)",
              "type": "string"
            },
            "user_timezone": {
              "default": "",
              "description": "User's timezone in IANA format. You MUST pass the timezone when it's available in your context. Required when `newer_than` is provided.",
              "type": "string"
            },
            "include_unread_status": {
              "default": false,
              "description": "Include unread message status, and count found in sample",
              "type": "boolean"
            }
          },
          "required": [
            "channels"
          ],
          "$defs": {
            "ChannelIdentifier": {
              "properties": {
                "channel_id_or_dm_id": {
                  "default": "",
                  "examples": [
                    "C1234567890",
                    "D1234567890"
                  ],
                  "type": "string"
                },
                "channel_name": {
                  "default": "",
                  "examples": [
                    "general",
                    "random"
                  ],
                  "type": "string"
                },
                "dm_username": {
                  "default": "",
                  "examples": [
                    "jeanne",
                    "john"
                  ],
                  "type": "string"
                },
                "thread_ts": {
                  "default": "",
                  "description": "Get messages from a specific thread timestamp",
                  "type": "string"
                }
              },
              "type": "object"
            }
          }
        },
        "outputSchema": {
          "type": "object",
          "properties": {
            "result": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "additionalProperties": true,
                  "type": "object"
                }
              ]
            }
          },
          "required": [
            "result"
          ],
          "x-fastmcp-wrap-result": true
        },
        "_meta": {
          "_fastmcp": {
            "tags": []
          }
        }
      },
      {
        "name": "search_messages",
        "description": "Search messages or files across Slack with complex filtering options and relevance sorting.\n\nIMPORTANT: If the user asks for messages sent from a specific person (including themselves),\nuse the `from_user_id_or_usernames` filter parameter immediately.\n\nSome special cases:\n- To find messages that mention the current user, include \"@me\" in the query terms,\n    e.g. \"some topic @me\", or just \"@me\" for any message\n- To find messages from the current user, add filter with `from_user_id_or_usernames.username=me`",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query_terms": {
              "default": "",
              "description": "For phrase search, use double quotes. For exclusion, use -exclude.",
              "type": "string"
            },
            "filter": {
              "anyOf": [
                {
                  "$ref": "#/$defs/SlackSearchFilter"
                },
                {
                  "type": "null"
                }
              ],
              "default": null
            },
            "count": {
              "default": 20,
              "maximum": 100,
              "type": "integer"
            },
            "page": {
              "default": 1,
              "type": "integer"
            },
            "sort_method": {
              "default": "by_relevance",
              "description": "Sort results by relevance (`by_relevance` - default) or time (`by_newest_time`). **NEVER USE by_newest_time UNLESS USER EXPLICITLY ASKS FOR CHRONOLOGICAL ORDER WITH WORDS LIKE 'latest', 'most recent', 'newest', 'chronological order'.** **ALWAYS USE by_relevance FOR ALL OTHER CASES INCLUDING TIME-FILTERED SEARCHES.** Use `by_relevance` for: search queries, finding relevant content, general searches, time-filtered searches. Use `by_newest_time` ONLY when user explicitly requests chronological ordering with specific keywords. Default assumption: user wants relevant results, not chronological results.",
              "enum": [
                "by_relevance",
                "by_newest_time"
              ],
              "examples": [
                {
                  "reason": "time filter but no chronological request",
                  "use": "by_relevance",
                  "user_says": "find messages about goose from past week"
                },
                {
                  "reason": "explicitly asked for 'latest'",
                  "use": "by_newest_time",
                  "user_says": "show me the latest messages about goose"
                },
                {
                  "reason": "general search",
                  "use": "by_relevance",
                  "user_says": "search for goose messages"
                }
              ],
              "type": "string"
            },
            "sort_dir": {
              "default": "desc",
              "enum": [
                "asc",
                "desc"
              ],
              "type": "string"
            },
            "search_type": {
              "default": "messages",
              "enum": [
                "messages",
                "files"
              ],
              "type": "string"
            },
            "user_timezone": {
              "default": "",
              "description": "User's timezone in IANA format. You MUST pass the timezone when it's available in your context.",
              "type": "string"
            }
          },
          "$defs": {
            "SlackSearchFilter": {
              "properties": {
                "in_channel_names": {
                  "description": "Limit to these channel names. Cannot be used for DMs.",
                  "examples": [
                    [
                      "#test-channel"
                    ]
                  ],
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                "in_dm_or_channel_ids": {
                  "description": "Limit to these DM IDs or channel IDs",
                  "examples": [
                    [
                      "C1234567890"
                    ],
                    [
                      "D1234567890"
                    ]
                  ],
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                "not_in_channel_names": {
                  "description": "Exclude from these channels",
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                "from_user_id_or_usernames": {
                  "description": "Messages sent from any of the given users",
                  "examples": [
                    {
                      "use": [
                        {
                          "real_name": "",
                          "user_id": "",
                          "username": "me"
                        }
                      ],
                      "user says": "summarize messages I sent"
                    },
                    {
                      "use": [
                        {
                          "real_name": "",
                          "user_id": "",
                          "username": "john"
                        }
                      ],
                      "user says": "find messages from john"
                    },
                    {
                      "use": [
                        {
                          "real_name": "",
                          "user_id": "U1234567890",
                          "username": ""
                        }
                      ],
                      "user says": "find messages from user U1234567890"
                    },
                    {
                      "use": [
                        {
                          "real_name": "John Doe",
                          "user_id": "",
                          "username": ""
                        }
                      ],
                      "user says": "find messages from John Doe"
                    }
                  ],
                  "items": {
                    "$ref": "#/$defs/UserSelector"
                  },
                  "type": "array"
                },
                "not_from_user_id_or_usernames": {
                  "description": "Exclude messages from these users",
                  "items": {
                    "$ref": "#/$defs/UserSelector"
                  },
                  "type": "array"
                },
                "with_user_id_or_usernames": {
                  "description": "Messages in DMs or threads with these users",
                  "items": {
                    "$ref": "#/$defs/UserSelector"
                  },
                  "type": "array"
                },
                "creator_id_or_username": {
                  "anyOf": [
                    {
                      "$ref": "#/$defs/UserSelector"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Canvas messages created by this user"
                },
                "has_reaction": {
                  "default": "",
                  "description": "With this emoji",
                  "type": "string"
                },
                "has_my_reaction": {
                  "default": "",
                  "description": "Messages you reacted to with this emoji",
                  "type": "string"
                },
                "is_pinned": {
                  "default": false,
                  "description": "Only pinned messages",
                  "type": "boolean"
                },
                "is_saved": {
                  "default": false,
                  "description": "Messages saved to your Saved Items",
                  "type": "boolean"
                },
                "is_thread": {
                  "default": false,
                  "description": "Messages that started threads",
                  "type": "boolean"
                },
                "is_reply": {
                  "default": false,
                  "description": "Replies within threads",
                  "type": "boolean"
                },
                "has_file": {
                  "default": false,
                  "description": "Messages that include files",
                  "type": "boolean"
                },
                "file_type": {
                  "default": "",
                  "description": "Limit to specific file types",
                  "type": "string"
                },
                "before": {
                  "anyOf": [
                    {
                      "format": "date",
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Messages before this date."
                },
                "after": {
                  "anyOf": [
                    {
                      "format": "date",
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Messages after this date."
                },
                "on": {
                  "anyOf": [
                    {
                      "format": "date",
                      "type": "string"
                    },
                    {
                      "enum": [
                        "today",
                        "yesterday"
                      ],
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Messages on this exact date."
                },
                "newer_than": {
                  "anyOf": [
                    {
                      "format": "duration",
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null,
                  "description": "Messages newer than this timedelta period. Use newer_than parameter when the user is requesting messages from N days ago.Must be in ISO 8601 duration format.",
                  "examples": [
                    "P7D",
                    "P1D",
                    "PT5H"
                  ]
                },
                "during": {
                  "default": "",
                  "description": "Messages during a specific time (e.g. 'august', '2023')",
                  "type": "string"
                },
                "newer_than_timezone": {
                  "default": "",
                  "description": "Timezone required when newer_than is provided. IANA format.",
                  "type": "string"
                }
              },
              "type": "object"
            },
            "UserSelector": {
              "properties": {
                "user_id": {
                  "default": "",
                  "type": "string"
                },
                "username": {
                  "default": "",
                  "type": "string"
                },
                "real_name": {
                  "default": "",
                  "type": "string"
                }
              },
              "type": "object"
            }
          }
        },
        "outputSchema": {
          "type": "object",
          "properties": {
            "result": {
              "anyOf": [
                {
                  "additionalProperties": true,
                  "type": "object"
                },
                {
                  "type": "string"
                }
              ]
            }
          },
          "required": [
            "result"
          ],
          "x-fastmcp-wrap-result": true
        },
        "_meta": {
          "_fastmcp": {
            "tags": []
          }
        }
      },
      {
        "name": "post_message",
        "description": "Post a message to a Slack channel or DM. Priority: dm_myself > username > channel_id/channel_name.\nNote: When using blocks, the text parameter serves as the notification/fallback text.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "text": {
              "description": "Message text to post. Also used as notification text for Block Kit. Supports Markdown, emojis, user mentions and channel mentions. Links with custom text <http://www.example.com|This message is a link>. Links to a channel <#C1234567890>. Mention a user <@U1234567890> (use get_user_info tool to resolve usernames to IDs if needed).",
              "examples": [
                "Some **bold** and *italic* text. ",
                "# Heading",
                "With an emoji :robot_face: for <@U1234567890> at channel <#C1234567890>"
              ],
              "type": "string"
            },
            "channel_id": {
              "default": "",
              "description": "Channel ID to post to (e.g., 'C1234567890') - ignored if dm_myself or username is provided",
              "type": "string"
            },
            "channel_name": {
              "default": "",
              "description": "Alternative to channel_id, ignored if dm_myself or username is provided",
              "type": "string"
            },
            "dm_myself": {
              "default": false,
              "description": "If true, sends message to your own DM. Overrides channel_id and username.",
              "type": "boolean"
            },
            "username": {
              "default": "",
              "description": "E.g., 'john'. Overrides channel_id and channel_name, unless dm_myself is true.",
              "type": "string"
            },
            "thread_ts": {
              "default": "",
              "description": "Parent message timestamp for posting a reply in thread.",
              "type": "string"
            },
            "blocks": {
              "anyOf": [
                {
                  "items": {
                    "additionalProperties": true,
                    "type": "object"
                  },
                  "type": "array"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Rich message formatting"
            },
            "attachments": {
              "anyOf": [
                {
                  "items": {
                    "additionalProperties": true,
                    "type": "object"
                  },
                  "type": "array"
                },
                {
                  "type": "null"
                }
              ],
              "default": null
            }
          },
          "required": [
            "text"
          ]
        },
        "outputSchema": {
          "type": "object",
          "additionalProperties": true
        },
        "_meta": {
          "_fastmcp": {
            "tags": []
          }
        }
      },
      {
        "name": "get_user_info",
        "description": "Get information for a list of users by ID, email, username, or real name.\nResponse includes user_id, username, timezone and more.\nPriority: user_id > email > username > real_name\nOnly one parameter should be provided for each user.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "inputs": {
              "description": "List of users to get info for",
              "items": {
                "$ref": "#/$defs/UserInfoInput"
              },
              "type": "array"
            }
          },
          "required": [
            "inputs"
          ],
          "$defs": {
            "UserInfoInput": {
              "properties": {
                "user_id": {
                  "default": "",
                  "type": "string"
                },
                "email": {
                  "default": "",
                  "type": "string"
                },
                "username": {
                  "default": "",
                  "examples": [
                    "john for john@block.xyz or john@squareup.com",
                    "me for the current user"
                  ],
                  "type": "string"
                },
                "real_name": {
                  "default": "",
                  "examples": [
                    "John Doe for John Doe"
                  ],
                  "type": "string"
                }
              },
              "type": "object"
            }
          }
        },
        "outputSchema": {
          "type": "object",
          "additionalProperties": true
        },
        "_meta": {
          "_fastmcp": {
            "tags": []
          }
        }
      },
      {
        "name": "list_channels",
        "description": "List Slack channels and DMs and Multi DMs that the user is a Member of across all workspaces.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "limit": {
              "default": 200,
              "description": "Max number of items to return in API call to Slack",
              "maximum": 1000,
              "type": "integer"
            },
            "cursor": {
              "default": "",
              "description": "For next page",
              "type": "string"
            },
            "channel_types": {
              "default": "public_channel,private_channel",
              "description": "Comma-separated types: public_channel,private_channel,mpim,im",
              "type": "string"
            },
            "fields": {
              "anyOf": [
                {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Fields to include in response, e.g., ['id', 'name;, 'type']"
            },
            "name_filter": {
              "default": "",
              "description": "Case-insensitive substring to filter channel names",
              "type": "string"
            }
          }
        },
        "outputSchema": {
          "type": "object",
          "additionalProperties": true
        },
        "_meta": {
          "_fastmcp": {
            "tags": []
          }
        }
      },
      {
        "name": "get_channel_info",
        "description": "Get information about a Slack channel you're a Member of.\n\nDIRECT LOOKUP OPTIONS (use these first):\n- For channels: Use either channel_name or channel_id_or_dm_id\n- For DMs: Use dm_username or channel_id_or_dm_id\n\nProvide only one of channel_name, channel_id_or_dm_id, or dm_username.\nReturns information including name, id, number of members, and more.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "channel_id_or_dm_id": {
              "default": "",
              "examples": [
                "C1234567890",
                "D1234567890"
              ],
              "type": "string"
            },
            "channel_name": {
              "default": "",
              "examples": [
                "general",
                "random"
              ],
              "type": "string"
            },
            "dm_username": {
              "default": "",
              "examples": [
                "jeanne",
                "john"
              ],
              "type": "string"
            }
          }
        },
        "outputSchema": {
          "type": "object",
          "additionalProperties": true
        },
        "_meta": {
          "_fastmcp": {
            "tags": []
          }
        }
      },
      {
        "name": "message_tool",
        "description": "Slack message operations.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "channel_id": {
              "description": "For the message",
              "type": "string"
            },
            "message_ts": {
              "type": "string"
            },
            "operation": {
              "enum": [
                "get_message_reactions",
                "get_message_info",
                "add_reaction",
                "remove_reaction",
                "update_message",
                "delete_message"
              ],
              "type": "string"
            },
            "full_reactions": {
              "description": "Whether to get full reactions (for get_message_reactions)",
              "type": "boolean"
            },
            "emoji": {
              "default": "",
              "description": "For add_reaction/remove_reaction",
              "type": "string"
            },
            "text": {
              "default": "",
              "description": "For update_message",
              "type": "string"
            }
          },
          "required": [
            "channel_id",
            "message_ts",
            "operation",
            "full_reactions"
          ]
        },
        "outputSchema": {
          "type": "object",
          "additionalProperties": true
        },
        "_meta": {
          "_fastmcp": {
            "tags": []
          }
        }
      },
      {
        "name": "misc_read",
        "description": "Slack read operations.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "operation": {
              "enum": [
                "get_workspaces",
                "get_user_profile",
                "list_user_reactions",
                "get_presence",
                "get_dnd_info",
                "list_scheduled_messages",
                "get_channel_members"
              ],
              "type": "string"
            },
            "authenticated_user_id": {
              "default": "",
              "description": "For get_workspaces",
              "type": "string"
            },
            "team_id": {
              "default": "",
              "description": "For list_user_reactions",
              "type": "string"
            },
            "user_id": {
              "default": "",
              "description": "For list_user_reactions",
              "type": "string"
            },
            "channel_id": {
              "default": "",
              "description": "For list_scheduled_messages and get_channel_members",
              "type": "string"
            },
            "extra_params": {
              "anyOf": [
                {
                  "additionalProperties": true,
                  "type": "object"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Optional: count, page, full (for list_user_reactions); cursor, limit (for list_scheduled_messages)."
            }
          },
          "required": [
            "operation"
          ]
        },
        "outputSchema": {
          "type": "object",
          "additionalProperties": true
        },
        "_meta": {
          "_fastmcp": {
            "tags": []
          }
        }
      },
      {
        "name": "misc_write",
        "description": "Slack write operations.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "operation": {
              "enum": [
                "schedule_message",
                "delete_scheduled_message",
                "set_status",
                "clear_status",
                "set_presence",
                "set_dnd",
                "end_dnd",
                "set_ooo_status",
                "set_channel_topic",
                "set_channel_description"
              ],
              "type": "string"
            },
            "schedule_message_params": {
              "anyOf": [
                {
                  "$ref": "#/$defs/ScheduleMessageParams"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "description": "Parameters to schedule a message"
            },
            "channel_id": {
              "default": "",
              "description": "For delete_scheduled_message, set_channel_topic, and set_channel_description",
              "type": "string"
            },
            "schedule_message_id": {
              "default": "",
              "description": "For delete_scheduled_message",
              "type": "string"
            },
            "set_status_params": {
              "anyOf": [
                {
                  "$ref": "#/$defs/SetStatusParams"
                },
                {
                  "type": "null"
                }
              ],
              "default": null
            },
            "presence": {
              "anyOf": [
                {
                  "enum": [
                    "auto",
                    "away"
                  ],
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null
            },
            "num_minutes": {
              "default": 0,
              "type": "integer"
            },
            "set_ooo_status_params": {
              "anyOf": [
                {
                  "$ref": "#/$defs/SetOOOStatusParams"
                },
                {
                  "type": "null"
                }
              ],
              "default": null
            },
            "topic": {
              "default": null,
              "description": "New Topic to use for set_channel_topic",
              "type": "string"
            },
            "description": {
              "default": null,
              "description": "New Description to use for set_channel_description",
              "type": "string"
            }
          },
          "required": [
            "operation"
          ],
          "$defs": {
            "ScheduleMessageParams": {
              "description": "Provide either `post_at` (ISO datetime) or `post_delay` (ISO duration).\nTimezone is required (e.g., 'America/New_York')\nAsk the user to specify their timezone explicitly. Never assume a timezone.",
              "properties": {
                "channel_id": {
                  "type": "string"
                },
                "text": {
                  "description": "Message text to post. Supports Markdown, emojis, user mentions and channel mentions. ",
                  "type": "string"
                },
                "post_at": {
                  "anyOf": [
                    {
                      "format": "date-time",
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null
                },
                "timezone": {
                  "default": "",
                  "type": "string"
                },
                "post_delay": {
                  "anyOf": [
                    {
                      "format": "duration",
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "default": null
                },
                "thread_ts": {
                  "default": "",
                  "type": "string"
                },
                "reply_broadcast": {
                  "default": false,
                  "type": "boolean"
                }
              },
              "required": [
                "channel_id",
                "text"
              ],
              "type": "object"
            },
            "SetOOOStatusParams": {
              "description": "Dates in YYYY-MM-DD format, emoji as Unicode escapes",
              "properties": {
                "start_date": {
                  "type": "string"
                },
                "end_date": {
                  "type": "string"
                },
                "message": {
                  "default": "Out of Office",
                  "type": "string"
                },
                "emoji": {
                  "default": "",
                  "type": "string"
                },
                "status_expiration": {
                  "default": 0,
                  "type": "integer"
                }
              },
              "required": [
                "start_date",
                "end_date"
              ],
              "type": "object"
            },
            "SetStatusParams": {
              "properties": {
                "status_text": {
                  "default": "",
                  "type": "string"
                },
                "status_emoji": {
                  "default": "",
                  "description": "Emoji to set. Use Unicode escapes for emoji (e.g., '\\ud83e\\udd16' for robot).",
                  "type": "string"
                },
                "status_expiration": {
                  "default": 0,
                  "type": "integer"
                }
              },
              "type": "object"
            }
          }
        },
        "outputSchema": {
          "type": "object",
          "additionalProperties": true
        },
        "_meta": {
          "_fastmcp": {
            "tags": []
          }
        }
      }
    ]
  }
}